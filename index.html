<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ma Tête 3D</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: transparent;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.5rem;
            z-index: 10;
        }

        .spinner {
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top: 3px solid white;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div class="loading" id="loading">
        <div class="spinner"></div>
        Chargement...
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        let scene, camera, renderer, model;
        
        function init() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 5);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0); // Fond transparent
            container.appendChild(renderer.domElement);
            
            // Éclairage
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);
            
            // Chargement du modèle
            const loader = new THREE.GLTFLoader();
            loader.load(
                './model.glb', // Votre fichier doit s'appeler exactement "model.glb"
                function(gltf) {
                    model = gltf.scene;
                    
                    // Ajuster la taille
                    const box = new THREE.Box3().setFromObject(model);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    const maxSize = Math.max(size.x, size.y, size.z);
                    const scale = 2 / maxSize;
                    
                    model.scale.multiplyScalar(scale);
                    model.position.sub(center.multiplyScalar(scale));
                    
                    scene.add(model);
                    document.getElementById('loading').style.display = 'none';
                },
                undefined,
                function(error) {
                    console.error('Erreur:', error);
                    document.getElementById('loading').innerHTML = 'Erreur de chargement';
                }
            );
            
            // Contrôles souris basiques
            let mouseDown = false;
            let mouseX = 0, mouseY = 0;
            
            document.addEventListener('mousedown', (e) => {
                mouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            document.addEventListener('mouseup', () => mouseDown = false);
            document.addEventListener('mousemove', (e) => {
                if (!mouseDown || !model) return;
                const deltaX = e.clientX - mouseX;
                const deltaY = e.clientY - mouseY;
                model.rotation.y += deltaX * 0.01;
                model.rotation.x += deltaY * 0.01;
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            // Zoom avec la molette de la souris
            document.addEventListener('wheel', (e) => {
                e.preventDefault();
                camera.position.z += e.deltaY * 0.01;
                camera.position.z = Math.max(1, Math.min(20, camera.position.z)); // Limites de zoom
            }, { passive: false });
            
            // Zoom tactile pour mobile (pinch)
            let lastTouchDistance = 0;
            document.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    lastTouchDistance = Math.sqrt(
                        Math.pow(touch2.clientX - touch1.clientX, 2) +
                        Math.pow(touch2.clientY - touch1.clientY, 2)
                    );
                }
            });
            
            document.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    const distance = Math.sqrt(
                        Math.pow(touch2.clientX - touch1.clientX, 2) +
                        Math.pow(touch2.clientY - touch1.clientY, 2)
                    );
                    
                    if (lastTouchDistance > 0) {
                        const delta = distance - lastTouchDistance;
                        camera.position.z -= delta * 0.01;
                        camera.position.z = Math.max(1, Math.min(20, camera.position.z));
                    }
                    lastTouchDistance = distance;
                }
            }, { passive: false });
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            animate();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (model) {
                model.rotation.y += 0.005; // Rotation automatique
            }
            
            renderer.render(scene, camera);
        }
        
        window.addEventListener('load', init);
    </script>
</body>
</html>